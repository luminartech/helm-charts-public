---
## @section Global parameters
## Global parameters
## These variables are accessible to all dependency helm charts.
##

global:
  ## @param global.chartNameOverride Overrides the chart name.
  ##
  chartNameOverride: ""
  ## @param global.releaseNameOverride Overrides the release name.
  ##
  releaseNameOverride: ""
  ## @param global.tags Define common tags for all IAC and app resources generated by this chart.
  ##
  tags: {}
  ## @param global.labels Define common labels for all IAC and app resources generated by this chart.
  ##
  labels: {}
  ## @param global.annotations Define common annotations for all IAC and app resources generated by this chart.
  ##
  annotations: {}
  ## @param global.awsAccountId Default aws account id for crossplane aws provider resources. Quotes are important, value must be a string.
  ##
  awsAccountId: "0123456789"
  ## @param global.awsMgmtAccountId Default aws account id of the main crossplane management instance. Quotes are important, value must be a string.
  ##
  awsMgmtAccountId: "00000000000"
  ## @param global.awsRegion Default aws region for crossplane aws provider resources.
  ##
  awsRegion: us-east-2
  ## @param global.eksHash Default EKS cluster hash for relevant crossplane resources such as IAM Role.
  ##
  eksHash: "XXXXX"
  ## @param global.eksClusterName Default EKS cluster hash for relevant crossplane resources such as IAM Role.
  ##
  eksClusterName: "infra-aws-eks"
  ## @param global.providerConfigRef.name Default crossplane provider all resources generated for crossplane.
  ##
  providerConfigRef:
    name: crossplane-provider-config-aws
  ## @param global.awsDeletionPolicy Default crossplane deletion policy for all resources deployed by this helm chart..
  ## This can be overriden for each resource in its section
  awsDeletionPolicy: Orphan
  ## @param global.secretStoreRef External Secrets secret store ref to fetch AWS secret for repo creds
  ##
  secretStoreRef: cluster-secret-store-aws
  ## @param global.githubOrg Github Org for accessing repos using github app
  ##
  githubOrg: satish-labs
  ## @param global.environment Used for identifying secret path in the AWS secrets
  ##
  environment: dev
  ## @param global.team Used for identifying secret path in the AWS secrets
  ##
  team: infra
  ## @param global.ingressUrl Ingress URL to use for additional ingress.
  ## Note: Internal ingress object supplied by upstream argocd helm chart do not use this variable
  ##
  ingressUrl: argo-cd.dev.domain.com
  ## @param global.ingressClassNameExternal External facing ingress class name, used for webhooks
  ##
  ingressClassNameExternal: 'nginx-ingress-external'
  ## @param global.ingressClassNameInternal Internal facing ingress class name for argocd UI
  ##
  ingressClassNameInternal: 'nginx-ingress-internal'
  ## @param global.certIssuer External Secrets secret store ref to fetch AWS secret for repo creds
  ##
  certIssuer: 'dev-satishweb-com'
  ## @skip global.securityContext
  ##
  securityContext:
    runAsUser: 999
    runAsGroup: 999
    fsGroup: 999
  ## @skip global.logging
  ##
  logging:
    format: json
    level: info

## @section ArgoCDExtension
## @skip ArgoCDExtension
ArgoCDExtension:
  enabled: false

## @section crossplane-aws-iam
## @skip crossplane-aws-iam
crossplane-aws-iam:
  enabled: false
  Policy:
    items:
      _:
        forProvider:
          description: "IAM Policy for argo-cd to access aws services"
          policy:
            Statement:
              allowECRRead:
                Effect: Allow
                Action:
                  - ecr:DescribeRegistry
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchGetImage
                  - ecr:DescribeImages
                  - ecr:GetAuthorizationToken
                  - ecr:DescribeRepositories
                  - ecr:ListImages
                  - ecr:BatchCheckLayerAvailability
                  - sts:AssumeRole
                Resource: '*'
  Role:
    items:
      _:
        forProvider:
          assumeRolePolicy:
            Statement:
              allowAssumeRoleWebIdentity:
                Effect: 'Allow'
                Action: 'sts:AssumeRoleWithWebIdentity'
                Principal:
                  Federated: 'arn:aws:iam::{{ .Values.global.awsAccountId }}:oidc-provider/oidc.eks.{{ .Values.global.awsRegion }}.amazonaws.com/id/{{ .Values.global.eksHash }}'
                Condition:
                  StringEquals:
                    'oidc.eks.{{ .Values.global.awsRegion }}.amazonaws.com/id/{{ .Values.global.eksHash }}:sub': 'system:serviceaccount:{{ .Release.Namespace }}:argocd-application-controller'
                    'oidc.eks.{{ .Values.global.awsRegion }}.amazonaws.com/id/{{ .Values.global.eksHash }}:aud': 'sts.amazonaws.com'
              allowEC2AssumeRole:
                Effect: Allow
                Principal:
                  Service: 'ec2.amazonaws.com'
                Action: 'sts:AssumeRole'
              allowSelfAssumeRole:
                Effect: Allow
                Principal:
                  AWS: '*'
                Action: 'sts:AssumeRole'
                Condition:
                  ArnLike:
                    'aws:PrincipalArn': 'arn:aws:iam::{{ .Values.global.awsAccountId }}:role/{{ include "common-gitops.names.release" . }}'
  RolePolicyAttachment:
    items:
      _:
        forProvider:
          policyArnRef:
            name: '{{ include "common-gitops.names.release" . }}'
          roleRef:
            name: '{{ include "common-gitops.names.release" . }}'

## @section argo-cd
## @skip argo-cd
argo-cd:
  enabled: false
  crds:
    install: true
    keep: true
  controller:
    replicas: 2
    resources:
      limits:
        cpu: 1000m
        memory: 2000Mi
      requests:
        cpu: 700m
        memory: 1500Mi
    enableStatefulSet: true
    clusterAdminAccess:
      enabled: true
    clusterRoleRules:
      enabled: true
      rules:
        - apiGroups:
          - '*'
          resources:
          - '*'
          verbs:
          - '*'
        - nonResourceURLs:
          - '*'
          verbs:
          - '*'
    serviceAccount:
      create: true
    metrics:
      enabled: false
      serviceMonitor:
        enabled: false
        additionalLabels:
          release: monitoring
  createAggregateRoles: true
  server:
    resources:
      limits:
        cpu: "1"
        memory: 1Gi
      requests:
        cpu: 500m
        memory: 512Mi
    configEnabled: true
    extensions:
      enabled: true
    autoscaling:
      enabled: false
      minReplicas: 5
      maxReplicas: 10
      targetCPUUtilizationPercentage: 70
      targetMemoryUtilizationPercentage: 70
    apiVersionOverrides:
      certmanager: "" # cert-manager.io/v1
      ingress: "" # networking.k8s.io/v1beta1
    ingress:
      enabled: false
    ingressGrpc:
      enabled: false
    metrics:
      enabled: false
      serviceMonitor:
        enabled: false
        additionalLabels:
          release: monitoring
    config:
      resource.customizations: |
        "*.aws.upbound.io/*":
          health.lua.useOpenLibs: true
          health.lua: |
            hs = {
              status = "Progressing",
              message = "Waiting for resource to be created"
            }
            if obj.status and obj.status.conditions then
              healthy = true
              message_parts = {}
              for i, condition in ipairs(obj.status.conditions) do
                if healthy and condition.status ~= "True" then
                  healthy = false
                end
                table.insert(message_parts, condition.reason)
              end
              hs.message = table.concat(message_parts, ", ")
              if healthy then
                hs.status = "Healthy"
              else
                hs.status = "Degraded"
              end
            end
            return hs

        "external-secrets.io/*":
          health.lua: |
            hs = {}
            if obj.status ~= nil then
              if obj.status.conditions ~= nil then
                ready = false
                ready_message = ""
                for i, condition in ipairs(obj.status.conditions) do
                  if condition.type == "Ready" then
                    ready = condition.status == "True"
                    ready_message = condition.reason
                  end
                end
                if ready then
                  hs.status = "Healthy"
                else
                  hs.status = "Degraded"
                end
                hs.message = ready_message
                return hs
              end
            end
            hs.status = "Progressing"
            hs.message = "Waiting for provider to be installed"
            return hs

      resource.customizations.useOpenLibs.eks.aws.crossplane.io_Addon: "true"
      resource.customizations.health.eks.aws.crossplane.io_Addon: |
        hs = {}
        if obj.status ~= nil then
          if obj.status.conditions ~= nil then
            synced, ready = false, false
            synced_message, ready_message, provider_status = "", ""
            for i, condition in ipairs(obj.status.conditions) do
              if condition.type == "Synced" then
                if condition.message ~= nil and
                    string.find(condition.message, 'desired') ~= nil then
                  synced = true
                else
                  synced = condition.status == "True"
                  synced_message = condition.reason
                end
              end
              if condition.type == "Ready" then
                ready = condition.status == "True"
                ready_message = condition.reason
              end
              if obj.status.atProvider.status ~= nil then
                provider_status = obj.status.atProvider.status
              end
            end
            if synced and ready then
              hs.status = "Healthy"
            else
              hs.status = "Degraded"
            end
            hs.message = table.concat({synced_message, ready_message, provider_status}, ", ")
            -- hs.message = synced_message .. " - " .. ready_message
            return hs
          end
        end
        hs.status = "Progressing"
        hs.message = "Waiting for provider to be installed"
        return hs

      resource.customizations.useOpenLibs.eks.aws.crossplane.io_Cluster: "true"
      resource.customizations.health.eks.aws.crossplane.io_Cluster: |
        hs = {}
        if obj.status ~= nil then
          if obj.status.conditions ~= nil then
            synced, ready = false, false
            synced_message, ready_message, provider_status = "", ""
            for i, condition in ipairs(obj.status.conditions) do
              if condition.type == "Synced" then
                if condition.message ~= nil and
                    string.find(condition.message, 'desired') ~= nil then
                  synced = true
                else
                  synced = condition.status == "True"
                  synced_message = condition.reason
                end
              end
              if condition.type == "Ready" then
                ready = condition.status == "True"
                ready_message = condition.reason
              end
              if obj.status.atProvider.status ~= nil then
                provider_status = obj.status.atProvider.status
              end
            end
            if synced and ready then
              hs.status = "Healthy"
            else
              hs.status = "Degraded"
            end
            hs.message = table.concat({synced_message, ready_message, provider_status}, ", ")
            -- hs.message = synced_message .. " - " .. ready_message
            return hs
          end
        end
        hs.status = "Progressing"
        hs.message = "Waiting for provider to be installed"
        return hs

      resource.customizations.health.eks.aws.crossplane.io_NodeGroup: |
        hs = {}
        if obj.status ~= nil then
          if obj.status.conditions ~= nil then
            synced, ready = false, false
            synced_message, ready_message = "", ""
            for i, condition in ipairs(obj.status.conditions) do
              if condition.type == "Synced" then
                synced = condition.status == "True"
                synced_message = condition.reason
              end
              if condition.type == "Ready" then
                ready = condition.status == "True"
                ready_message = condition.reason
              end
            end
            if synced and ready then
              hs.status = "Healthy"
            else
              hs.status = "Degraded"
            end
            hs.message = synced_message .. " - " .. ready_message
            return hs
          end
        end
        hs.status = "Progressing"
        hs.message = "Waiting for provider to be installed"
        return hs

      resource.customizations.health.kubernetes.crossplane.io_Object: |
        hs = {}
        if obj.status ~= nil then
          if obj.status.conditions ~= nil then
            synced = false
            synced_message = ""
            for i, condition in ipairs(obj.status.conditions) do
              if condition.type == "Synced" then
                synced = condition.status == "True"
                synced_message = condition.reason
              end
            end
            if synced then
              hs.status = "Healthy"
            else
              hs.status = "Degraded"
            end
            hs.message = synced_message
            return hs
          end
        end
        hs.status = "Progressing"
        hs.message = "Waiting for provider to be installed"
        return hs

    serviceAccount:
      create: true
    loglevel: info
    logFormat: json

  # the new way to describe repos
  configs:
    rbac:
      # TODO: This RBAC needs to moved to the team gitops repositories
      # Built in roles and configs: https://github.com/argoproj/argo-cd/blob/master/assets/builtin-policy.csv
      policy.csv: |
        p, role:service-accounts, applicationsets, get, */*, allow
        p, role:service-accounts, applicationsets, sync, */*, allow
        p, role:service-accounts, applicationsets, update, test/*, allow
        p, role:service-accounts, applicationsets, delete, test/*, allow
        p, role:service-accounts, applicationsets, create, test/*, allow
        p, role:service-accounts, applications, get, */*, allow
        p, role:service-accounts, applications, sync, */*, allow
        p, role:service-accounts, applications, update, test/*, allow
        p, role:service-accounts, applications, delete, test/*, allow
        p, role:service-accounts, applications, create, test/*, allow
        p, role:service-accounts, clusters, get, *, allow
        p, role:service-accounts, clusters, create, *, allow
        p, role:service-accounts, clusters, update, *, allow
        p, role:service-accounts, clusters, delete, *, allow
        p, role:service-accounts, repositories, get, *, allow
        p, role:service-accounts, gpgkeys, get, *, allow
        g, ci-service, role:service-accounts
        g, sec-argocd-admins, role:admin
      policy.default: 'role:readonly'
      scopes: '[email,groups]'
    cm:
      create: true
      url: "https://argo-cd.dev.domain.com"
      server.rbac.log.enforce.enable: true
    # TODO: All of these repositories needs to be reviewed and moved as secrets
    repositories:
      helm-helm-repo:
        url: https://charts.helm.sh/stable
        type: helm
        name: stable
      argocd-helm-repo:
        url: https://argoproj.github.io/argo-helm
        type: helm
        name: argo
      bitnami-helm-repo:
        url: https://charts.bitnami.com/bitnami
        type: helm
        name: bitnami
      jetstack-helm-repo:
        url: https://charts.jetstack.io
        type: helm
        name: jetstack
      ory-helm-repo:
        url: https://k8s.ory.sh/helm/charts
        type: helm
        name: ory
      actions-runner-controller-helm-repo:
        url: https://actions-runner-controller.github.io/actions-runner-controller
        type: helm
        name: actions-runner-controller
      reloader-helm-repo:
        url: https://stakater.github.io/stakater-charts
        type: helm
        name: reloader
      oauth2-proxy-helm-repo:
        url: https://oauth2-proxy.github.io/manifests
        type: helm
        name: oauth2-proxy
      mittwald-helm-repo:
        url: https://helm.mittwald.de
        type: helm
        name: mittwald
      ingress-nginx-helm-repo:
        url: https://kubernetes.github.io/ingress-nginx
        type: helm
        name: ingress-nginx
      harbor-helm-repo:
        url: https://helm.goharbor.io
        type: helm
        name: harbor
      elastic-helm-repo:
        url: https://helm.elastic.co
        type: helm
        name: elastic
      sonatype-helm-repo:
        url: https://sonatype.github.io/helm3-charts
        type: helm
        name: sonatype
      gitlab-helm-repo:
        url: http://charts.gitlab.io/
        type: helm
        name: gitlab
      eks-helm-repo:
        url: https://aws.github.io/eks-charts
        type: helm
        name: eks
      karpenter-helm-repo:
        url: https://charts.karpenter.sh
        type: helm
        name: karpenter
      karpenter-oci-helm-repo:
        url: public.ecr.aws/karpenter/karpenter
        type: helm
        name: karpenter
        enableOCI: "true"
      jfrog-helm-repo:
        url: https://charts.jfrog.io
        type: helm
        name: jfrog
      rook-release-helm-repo:
        url: https://charts.rook.io/release
        type: helm
        name: rook-release
      prometheus-community-helm-repo:
        url: https://prometheus-community.github.io/helm-charts
        type: helm
        name: prometheus-community
      aws-efs-csi-driver-helm-repo:
        url: https://kubernetes-sigs.github.io/aws-efs-csi-driver
        type: helm
        name: aws-efs-csi-driver
      signoz-helm-repo:
        url: https://charts.signoz.io
        type: helm
        name: signoz
      jbw-s-helm-repo:
        url: https://bjw-s.github.io/helm-charts
        type: helm
        name: jbw-s
      gabe565-helm-repo:
        url: https://charts.gabe565.com
        type: helm
        name: gabe565
      nvidia-helm-repo:
        url: https://nvidia.github.io/gpu-operator
        type: helm
        name: nvidia
      gpu-helm-charts-helm-repo:
        url: https://nvidia.github.io/dcgm-exporter/helm-charts
        type: helm
        name: gpu-helm-charts
      jkroepke-helm-repo:
        url: https://jkroepke.github.io/helm-charts/
        type: helm
        name: jkroepke
      deliveryhero:
        url: https://charts.deliveryhero.io/
        type: helm
        name: deliveryhero
      falcosecurity:
        url: https://falcosecurity.github.io/charts
        type: helm
        name: falcosecurity
      devopstales:
        url: https://devopstales.github.io/helm-charts
        type: helm
        mame: devopstales
      giantswarm:
        url: https://giantswarm.github.io/giantswarm-catalog
        type: helm
        name: giantswarm
      external-secrets:
        url: https://charts.external-secrets.io
        name: external-secrets
        type: helm
      appscode:
        url: https://charts.appscode.com/stable/
        name: appscode
        type: helm
      kubecost:
        url: https://kubecost.github.io/cost-analyzer/
        name: kubecost
        type: helm
      loft-sh:
        url: https://charts.loft.sh
        name: loft-sh
        type: helm
      kyverno:
        url: https://kyverno.github.io/kyverno/
        name: kyverno
        type: helm
      k8s-ephemeral-storage-metrics:
        url: https://jmcgrath207.github.io/k8s-ephemeral-storage-metrics/chart
        name: k8s-ephemeral-storage-metrics
        type: helm
  repoServer:
    replicas: 2
    resources:
      limits:
        cpu: 2000m
        memory: 2200Mi
      requests:
        cpu: 1500m
        memory: 2000Mi
    serviceAccount:
      create: true
    loglevel: info
    logFormat: json
    metrics:
      enabled: false
      serviceMonitor:
        enabled: false
        additionalLabels:
          release: monitoring
  dex:
    resources:
      limits:
        cpu: 100m
        memory: 100Mi
      requests:
        cpu: 20m
        memory: 20Mi
    serviceAccount:
      create: true
    metrics:
      enabled: false
      serviceMonitor:
        enabled: false
        additionalLabels:
          release: monitoring
  redis:
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 100m
        memory: 300Mi
  applicationSet:
    replicaCount: 2
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 150m
        memory: 200Mi
    serviceAccount:
      create: true
    metrics:
      enabled: false
      serviceMonitor:
        enabled: false
        additionalLabels:
          release: monitoring
  notifications:
    serviceAccount:
      create: true
    metrics:
      enabled: false
      serviceMonitor:
        enabled: false
        additionalLabels:
          release: monitoring

## @section common-res
## @skip common-res
common-res:
  enabled: false
  Ingress:
    items:
      argocd-webhook:
        enabled: true
        annotations:
          nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
          nginx.ingress.kubernetes.io/ssl-redirect: "true"
          nginx.ingress.kubernetes.io/server-snippet: |
            proxy_ssl_verify off;
            proxy_set_header X-Forwarded-Proto https;
          kubernetes.io/ingress.allow-http: "false"
          kubernetes.io/tls-acme: "true"
          cert-manager.io/acme-challenge-type: dns01
          cert-manager.io/acme-dns01-provider: route53
          cert-manager.io/cluster-issuer: '{{ .Values.global.certIssuer }}'
        spec:
          ingressClassName: '{{ .Values.global.ingressClassNameExternal }}'
          rules:
            - host: 'webhook-{{ .Values.global.ingressUrl }}'
              http:
                paths:
                  - path: /api/webhook
                    pathType: Exact
                    backend:
                      service:
                        name: '{{ include "common-gitops.names.release" . }}-argocd-server'
                        port:
                          number: 443
                  - path: /api/dex/callback
                    pathType: Exact
                    backend:
                      service:
                        name: '{{ include "common-gitops.names.release" . }}-argocd-server'
                        port:
                          number: 443
          tls:
            - secretName: 'tls-webhook-{{ .Values.global.ingressUrl }}'
              hosts:
                - 'webhook-{{ .Values.global.ingressUrl }}'

## @section external-secrets
## @skip external-secrets
external-secrets:
  enabled: false
  AWSExternalSecret:
    enabled: false
    items:
      _:
        name: '{{ .Values.global.team }}-{{ .Values.global.environment }}-gh-{{ .Values.global.githubOrg }}'
        labels:
          argocd.argoproj.io/secret-type: repo-creds
        source:
          secretStoreRef:
            name: '{{ .Values.global.secretStoreRef }}'
          data:
            url:
              awsSecretName: '{{ .Values.global.team }}-{{ .Values.global.environment }}/gh/{{ .Values.global.githubOrg }}'
              awsSecretKey: url
            githubAppID:
              awsSecretName: '{{ .Values.global.team }}-{{ .Values.global.environment }}/gh/{{ .Values.global.githubOrg }}'
              awsSecretKey: githubAppID
            githubAppInstallationID:
              awsSecretName: '{{ .Values.global.team }}-{{ .Values.global.environment }}/gh/{{ .Values.global.githubOrg }}'
              awsSecretKey: githubAppInstallationID
            app-client-secret:
              awsSecretName: '{{ .Values.global.team }}-{{ .Values.global.environment }}/gh/{{ .Values.global.githubOrg }}'
              awsSecretKey: app-client-secret
            app-client-id:
              awsSecretName: '{{ .Values.global.team }}-{{ .Values.global.environment }}/gh/{{ .Values.global.githubOrg }}'
              awsSecretKey: app-client-id
            githubAppPrivateKey:
              awsSecretName: '{{ .Values.global.team }}-{{ .Values.global.environment }}/gh/{{ .Values.global.githubOrg }}'
              awsSecretKey: githubAppPrivateKey
              # encode secret using command: base64 -w 0 /path/to/pem-key-file
              decodingStrategy: Base64

## @skip crossplane-aws-secretsmanager
crossplane-aws-secretsmanager:
  enabled: false
  Secret:
    enabled: false
    items:
      _:
        annotations:
          crossplane.io/external-name: '{{ .Values.global.team }}-{{ .Values.global.environment }}/gh/{{ .Values.global.githubOrg }}'
        apiVersion: secretsmanager.aws.upbound.io/v1beta1
        name: '{{ .Values.global.team }}-{{ .Values.global.environment }}-gh-{{ .Values.global.githubOrg }}'
        forProvider:
          name: '{{ .Values.global.team }}-{{ .Values.global.environment }}/gh/{{ .Values.global.githubOrg }}'
          description: "Github App Credentials for {{ .Values.global.team }}-{{ .Values.global.environment }} team"
